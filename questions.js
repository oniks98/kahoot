const shuffleArray = array => array.sort(() => Math.random() - 0.5);

const questions = [
  {
    question:
      ' Що таке DOCTYPE і для чого він потрібен? Що буде, якщо його не вказати?',
    answers: shuffleArray([
      {
        text: ' Оголошує тип документа та визначає версію HTML для браузера',
        correct: true,
      },
      {
        text: ' Вказує браузеру, яку кодову сторінку (charset) використовувати для відображення документа',
      },
      {
        text: ' Забороняє браузеру запускати JavaScript на сторінці до її повного завантаження',
      },
      {
        text: ' Визначає, які CSS-фреймворки потрібно підключити під час завантаження',
      },
    ]),
  },
  {
    question: ' Для чого потрібні мета-теги?',
    answers: shuffleArray([
      {
        text: ' Для зберігання інформації про сторінку (метаданих)',
        correct: true,
      },
      {
        text: ' Щоб автоматично змінювати колір фону залежно від розміру екрану',
      },
      { text: ' Для вбудованої оптимізації JavaScript-скриптів' },
      { text: ' Щоб встановити в документі XML-префікси для CSS-фреймворків' },
    ]),
  },
  {
    question: ' Чим відрізняється блочний елемент від рядкового?',
    answers: shuffleArray([
      {
        text: ' Блочний займає всю ширину доступного контейнера і починається з нового рядка, а рядковий — лише по ширині вмісту і продовжується в межах потоку всередині рядка',
        correct: true,
      },
      {
        text: ' Блочний не можна вставити в рядковий елемент, а рядковий завжди можна вкладати в блочний',
      },
      {
        text: ' Блочний елемент завжди має margin: auto за замовчуванням, а рядковий — ні',
      },
      {
        text: ' Рядкові елементи автоматично успадковують властивість display: inline-block, тоді як блочні — display: flex',
      },
    ]),
  },
  {
    question:
      ' Чому деякі символи можуть відображатись на сторінці у виді квадратів?',
    answers: shuffleArray([
      {
        text: ' Через відсутність потрібного шрифту або неправильно вказану кодування сторінки (наприклад, не встановлено UTF-8)',
        correct: true,
      },
      {
        text: ' Через конфлікт CSS-властивості letter-spacing із JavaScript, що виконується на сторінці',
      },
      {
        text: ' Тому що браузер не підтримує тег <meta name="description"> як джерело шрифтів',
      },
      {
        text: ' Через активовану опцію блокування кук, яка забороняє завантажувати шрифти з CDN',
      },
    ]),
  },
  {
    question: ' Що таке семантична верстка? Які семантичні теги знаєте?',
    answers: shuffleArray([
      {
        text: ' Верстка, яка використовує теги відповідно до їх смислового призначення для покращення доступності та SEO; приклади: <header>, <main>, <article>, <section>, <nav>, <footer>',
        correct: true,
      },
      {
        text: ' Верстка, при якій всі елементи сторінки побудовані винятково на основі таблиць (<table>) для кращої швидкодії',
      },
      {
        text: ' Верстка, що базується на використанні кастомних data-атрибутів для відображення вмісту замість класичних тегів',
      },
      {
        text: ' Верстка, у якій усі елементи мають display: inline, щоб зменшити кількість рядкових перенесень',
      },
    ]),
  },
  {
    question: ' Які типи заголовків існують в HTML?',
    answers: shuffleArray([
      { text: ' <h1>, <h2>, <h3>, <h4>, <h5>, <h6>', correct: true },
      { text: ' <h0>, <h1>, <h2>, <h3>, <h4>, <h5>' },
      { text: ' <h1>, <h2>, <h3>, <h4>, <h5>, <subtitle>' },
      {
        text: ' <header1>, <header2>, <header3>, <header4>, <header5>, <header6>',
      },
    ]),
  },
  {
    question:
      ' Що називається потоком документа в HTML? Чи можна його змінювати?',
    answers: shuffleArray([
      {
        text: ' Потік документа — це звичайний порядок рендерингу елементів згідно з їх розташуванням у DOM; змінити його можна за допомогою CSS-властивостей (float, position, flex, grid тощо)',
        correct: true,
      },
      {
        text: ' Потік документа — це порядок виконання скриптів JavaScript, і змінити його можна лише за допомогою async/defer',
      },
      {
        text: ' Потік документа — це порядок завантаження зображень, і змінюється він через параметр loading="lazy"',
      },
      {
        text: ' Потік документа — це черга HTTPS-запитів до сервера, яку можна регулювати тільки через HTTP/2',
      },
    ]),
  },
  {
    question:
      ' Які існують способи підключення JavaScript до html-сторінки? В чому між ними різниця?',
    answers: shuffleArray([
      {
        text: ' Через <script src="файл.js"> у <head> або перед </body>, а також inline-скрипти без атрибутів; різниця в синхронному (за замовчуванням), асинхронному (async) або відкладеному (defer) завантаженні',
        correct: true,
      },
      {
        text: ' Через тег <import src="скрипт.js">, який заміняє <script> у сучасних браузерах',
      },
      {
        text: ' Через атрибут data-js у будь-якому HTML-елементі, який автоматично запускає файл під час рендерингу',
      },
      {
        text: ' Через <?js include "скрипт.js"?> у тілі документа замість <script>',
      },
    ]),
  },
  {
    question: ' Які існують способи додавання CSS на сторінку?',
    answers: shuffleArray([
      {
        text: ' Inline-стилі (через атрибут style), внутрішній CSS у <style> у <head> та зовнішній CSS через <link rel="stylesheet">',
        correct: true,
      },
      {
        text: ' За допомогою тега <css src="стилі.css"> у будь-якій частині документа',
      },
      { text: ' Через <script type="text/css"> у <body>' },
      { text: ' Через атрибут data-style у кореневому елементі <html>' },
    ]),
  },
  {
    question: ' Різниця між reset.css і normalize.css?',
    answers: shuffleArray([
      {
        text: ' reset.css видаляє всі стилі браузера за замовчуванням, а normalize.css вирівнює стилі між браузерами, зберігаючи базове форматування',
        correct: true,
      },
      {
        text: ' reset.css призначений лише для старих версій Internet Explorer, а normalize.css — виключно для мобільних браузерів',
      },
      {
        text: ' reset.css змінює тільки типографіку (шрифти й інтервали), а normalize.css — лише кольори за замовчуванням',
      },
      {
        text: ' reset.css наповнений CSS-змінними (variables), а normalize.css завжди написаний у чистому CSS без змінних',
      },
    ]),
  },
  {
    question: ' Типи даних в JavaScript?',
    answers: shuffleArray([
      {
        text: ' String, Number, BigInt, Boolean, Null, Undefined, Symbol, Object',
        correct: true,
      },
      { text: ' String, Integer, Float, Boolean, Object, Array' },
      { text: ' Number, Text, Boolean, Collection, Undefined' },
      { text: ' Primitive, Reference, Function, Undefined' },
    ]),
  },
  {
    question: ' Що таке NaN?',
    answers: shuffleArray([
      {
        text: ' Спеціальне числове значення, яке означає «Not a Number» і повертається при невдалих математичних операціях',
        correct: true,
      },
      { text: ' Вбудований об’єкт для роботи з великими числами' },
      { text: ' Функція для перевірки, чи є значення числом' },
      { text: ' Тип даних, що позначає заповненість змінної значенням' },
    ]),
  },
  {
    question: ' Чим відрізняється строга рівність від не строгої (=== і ==)?',
    answers: shuffleArray([
      {
        text: ' === порівнює і тип, і значення без приведення, а == приводить типи перед порівнянням',
        correct: true,
      },
      { text: ' == працює лише з рядками, а === — лише з числами' },
      {
        text: ' === автоматично перетворює всі значення на Boolean, а == порівнює як є',
      },
      { text: ' == порівнює об’єкти за посиланням, а === — за вмістом' },
    ]),
  },
  {
    question: ' Яка різниця між null та undefined?',
    answers: shuffleArray([
      {
        text: ' undefined означає, що змінна оголошена, але не ініціалізована, а null — це явно присвоєне пусте або відсутнє значення',
        correct: true,
      },
      {
        text: ' null позначає рядок з пустою довжиною, а undefined — це число зі значенням нуль',
      },
      {
        text: ' undefined використовується в масивах, щоб вказати пропущений індекс, а null — в об’єктах',
      },
      {
        text: ' null означає, що змінна не існує, а undefined — що вона була оголошена десь раніше',
      },
    ]),
  },
  {
    question: ' Логічні оператори !, &&, ||. Як працюють?',
    answers: shuffleArray([
      {
        text: ' ! заперечує логічне значення, && повертає перше хибне значення або останнє істинне, || повертає перше істинне значення або останнє хибне',
        correct: true,
      },
      {
        text: ' && повертає true, якщо обидва вирази істинні, і false в іншому випадку, а || завжди повертає false, якщо зустрічає false',
      },
      {
        text: ' ! змінює число на протилежне за модулем, && порівнює довжину двох рядків, || відповідає за режим відлагодження',
      },
      {
        text: ' && виконує функцію лише тоді, коли обидва аргументи є функціями, а || лише коли один з аргументів є рядком',
      },
    ]),
  },
  {
    question: ' Що таке use strict і для чого він потрібен?',
    answers: shuffleArray([
      {
        text: ' Директива, що включає «строгий режим», у якому заборонені неявні глобальні змінні та інші небезпечні конструкції, що допомагає уникати помилок',
        correct: true,
      },
      {
        text: ' Спеціальний режим, який автоматично компілює код у двійковий формат для швидшого виконання',
      },
      {
        text: ' Директива, що дозволяє використовувати новий синтаксис модулів ES без Babel',
      },
      {
        text: ' Параметр, який змінює поведінку garbage collector і звільняє пам’ять негайно після виходу з функції',
      },
    ]),
  },
  {
    question: ' "Яка різниця між <script>, <script async> та <script defer>?"',
    answers: shuffleArray([
      {
        text: ' <script> блокує розбір HTML до виконання, async завантажується паралельно й виконується одразу після завантаження (позначення не гарантує порядок), defer завантажується паралельно, але виконується після розбору документа в порядку появи',
        correct: true,
      },
      {
        text: ' async відкладає виконання скрипта до події DOMContentLoaded, а defer виконує скрипт перед початком завантаження інших ресурсів',
      },
      {
        text: '<script> завантажується в кінці сторінки, async — від початку, а defer — у середині',
      },
      {
        text: ' defer виконує скрипт відразу, не чекаючи завантаження, а async чекає, доки всі зображення завантажаться',
      },
    ]),
  },
  {
    question: ' Чому результатом порівняння двох схожих об’єктів буде false?',
    answers: shuffleArray([
      {
        text: ' Тому що у JavaScript об’єкти (та масиви) порівнюються за посиланням, і навіть якщо їх вміст однаковий, різні змінні містять різні посилання',
        correct: true,
      },
      {
        text: ' Тому що при порівнянні об’єктів завжди викликається toString(), і оскільки він не перекриває властивості, повертається false',
      },
      {
        text: ' Тому що при порівнянні об’єктів JavaScript автоматично порівнює кількість ключів, і якщо вона парна — повертається false',
      },
      {
        text: ' Тому що об’єкти за замовчуванням мають властивість __unique, яка відрізняється навіть при однаковій структурі',
      },
    ]),
  },
  {
    question: ' Як перевірити ідентичність 2х об’єктів?',
    answers: shuffleArray([
      {
        text: ' Порівняти їхні посилання за допомогою === або Object.is(), або виконати глибоке порівняння полів вручну (наприклад, через цикли чи рекурсію)',
        correct: true,
      },
      {
        text: ' Використати оператор in, щоб перевірити наявність однакових ключів у двох об’єктах',
      },
      {
        text: ' Порівняти результат theirConstructor(), щоб переконатися, що вони мають однаковий конструктор',
      },
      {
        text: ' Викликати метод toFixed() на кожному об’єкті та порівняти рядки, які він поверне',
      },
    ]),
  },
  {
    question: ' Як зробити копію об’єкта?',
    answers: shuffleArray([
      {
        text: ' Використати Object.assign({}, obj) або оператор розпилення {...obj}, або JSON.parse(JSON.stringify(obj)) для глибокої копії',
        correct: true,
      },
      {
        text: ' Присвоїти новій змінній ліву частину старого об’єкта курсором, щоб автоматично дублювати дані',
      },
      {
        text: ' Викликати obj.clone(), який є вбудованим методом у кожному об’єкті JavaScript',
      },
      {
        text: ' Скористатися методом toArray() для перетворення об’єкта у масив, а потім назад у об’єкт',
      },
    ]),
  },
  {
    question: ' Для чого потрібен Virtual DOM в React?',
    answers: shuffleArray([
      {
        text: ' Для ефективного оновлення реального DOM через порівняння змін у легковаговій JS-репрезентації компонентів',
        correct: true,
      },
      {
        text: ' Щоб замінити браузерний рендеринг на серверний і уникнути роботи JavaScript на клієнті',
      },
      {
        text: ' Для автоматичного створення Shadow DOM навколо кожного компонента й інкапсуляції стилів',
      },
      {
        text: ' Щоб зберігати стан компонентів у локальному сховищі браузера й відновлювати його після перезавантаження',
      },
    ]),
  },
  {
    question: ' Різниця між virtual DOM та shadow DOM?',
    answers: shuffleArray([
      {
        text: ' Virtual DOM — це JS-репрезентація інтерфейсу, яка використовується React для дифінгу, а Shadow DOM — це браузерна технологія інкапсуляції стилів і структури в Web Components',
        correct: true,
      },
      {
        text: ' Virtual DOM створює окремий кореневий контейнер у документі, а Shadow DOM оновлює сторінку без перезавантаження',
      },
      {
        text: ' Virtual DOM відповідає за передзавантаження ресурсів, а Shadow DOM забезпечує серверний рендеринг React-компонентів',
      },
      {
        text: ' Virtual DOM інкапсулює CSS для компонентів, а Shadow DOM виконує дифінг і оновлює реальний DOM',
      },
    ]),
  },
  {
    question: ' В чому різниця між state та props?',
    answers: shuffleArray([
      {
        text: ' State — локальний змінний стан компонента, який може змінюватися всередині компонента, а props — дані, що передаються зверху, і їх не можна змінювати безпосередньо всередині приймаючого компонента',
        correct: true,
      },
      {
        text: ' State використовується тільки в функціональних компонентах, а props — тільки в класових компонентах',
      },
      { text: ' State завжди зберігається в Redux, а props — у Context API' },
      {
        text: ' State автоматично передається між компонентами, а props потрібні лише для методів життєвого циклу',
      },
    ]),
  },
  {
    question: ' Для чого потрібен key?',
    answers: shuffleArray([
      {
        text: ' Для унікальної ідентифікації елементів у списках, що допомагає React правильно відслідковувати зміни при ре-рендері',
        correct: true,
      },
      {
        text: ' Щоб встановити id елемента в DOM і використовувати його в CSS-селекторах',
      },
      {
        text: ' Для зберігання ключів шифрування даних у компонентах та передачі їх у бекенд',
      },
      {
        text: ' Щоб відключити автоматичне оновлення стану компонента та заблокувати його перерендер',
      },
    ]),
  },
  {
    question: ' Для чого потрібен Fragment?',
    answers: shuffleArray([
      {
        text: ' Для групування кількох дочірніх елементів без додавання зайвого DOM-елемента-обгортки',
        correct: true,
      },
      {
        text: ' Щоб створити новий Shadow DOM для кожного компонента та ізолювати стилі',
      },
      {
        text: ' Для автоматичного додавання <div> з класом “fragment” навколо всіх дітей компонента',
      },
      {
        text: ' Щоб зберігати стан компонента між його демонтажем та повторним монтуванням',
      },
    ]),
  },
  {
    question: ' Для чого потрібні портали?',
    answers: shuffleArray([
      {
        text: ' Для рендерингу дочірніх елементів у DOM-вузол, який знаходиться поза батьківським компонентом у дереві React, наприклад, для модальних вікон чи тултипів',
        correct: true,
      },
      {
        text: ' Щоб автоматично переносити компоненти на сервер для серверного рендерингу без зміни коду',
      },
      {
        text: ' Для включення CSS-фреймворку прямо з CDN, коли компонент монтується',
      },
      {
        text: ' Щоб створити окрему папку в файловій системі для збереження компонентів під час збірки',
      },
    ]),
  },
  {
    question: ' Що таке refs?',
    answers: shuffleArray([
      {
        text: ' Спосіб отримати безпосередній доступ до DOM-елементів або екземплярів класових компонентів у React для контролю фокусування, вимірювання розмірів або виклику методів',
        correct: true,
      },
      {
        text: ' Метод для динамічного імпортування стилів з інших компонентів під час рантайму',
      },
      {
        text: ' Спеціальний об’єкт у Redux для збереження глобального стану та передачі його в React-компоненти',
      },
      {
        text: ' API для визначення типів пропсів (propTypes) в класових компонентах',
      },
    ]),
  },
  {
    question: ' Що таке context? Скільки context може бути в проекті?',
    answers: shuffleArray([
      {
        text: ' Context — це механізм передачі даних через дерево компонентів без прокидання пропсів на кожному рівні; в проєкті може бути будь-яка кількість різних контекстів',
        correct: true,
      },
      {
        text: ' Context — це вбудований у React глобальний стан, обмежений тільки одним екземпляром на додаток',
      },
      {
        text: ' Context — це еквівалент Redux і замінює всі зовнішні бібліотеки для керування станом; може бути лише один контекст у проєкті',
      },
      {
        text: ' Context — це спеціальний тип props, який передається лише через портали; кількість обмежена до двох на компонент',
      },
    ]),
  },
  {
    question: ' Які можливості відкривають хуки? Які хуки ви знаєте?',
    answers: shuffleArray([
      {
        text: ' Хуки дозволяють використовувати стан і життєві цикли в функціональних компонентах; приклади: useState, useEffect, useContext, useReducer, useRef, useMemo, useCallback, useLayoutEffect',
        correct: true,
      },
      {
        text: ' Хуки — це методи для підключення зовнішніх CSS-фреймворків; наприклад, useCSS та useSass',
      },
      {
        text: ' Хуки — це класи, що замінюють компоненти, і мають життєві цикли, подібні до класових компонентів; наприклад, HookComponent та HookManager',
      },
      {
        text: ' Хуки — це спеціальні події React, які викликаються при зміні стану браузера або при натисканні клавіш; наприклад, useKeyPress та useResize',
      },
    ]),
  },
  {
    question: ' Які правила використання хуків?',
    answers: shuffleArray([
      {
        text: ' Хуки слід викликати лише у верхньому рівні функціональних компонентів або кастомних хуків, не всередині умов, циклів чи вкладених функцій, і використовувати тільки в React-функціональних компонентах',
        correct: true,
      },
      {
        text: ' Хуки можна викликати тільки в методах життєвого циклу класових компонентів для синхронізації стану',
      },
      {
        text: ' Хуки слід писати тільки у файлах з розширенням .hook.js, щоб вони автоматично імпортувалися в будь-який компонент',
      },
      {
        text: ' Хуки необхідно викликати прямо в JSX-розмітці, а не у тілі функції, щоб React міг відстежувати їх виконання',
      },
    ]),
  },
  {
    question: ' Що таке critical CSS?',
    answers: shuffleArray([
      {
        text: ' CSS, необхідний для початкового рендерингу сторінки, який завантажується й застосовується першочергово для пришвидшення відображення контенту',
        correct: true,
      },
      {
        text: ' CSS-фреймворк, що автоматично мінімізує всі стилі під час виробничої збірки',
      },
      {
        text: ' Концепція CSS, при якій всі стилі завантажуються через CDN для критичних браузерів',
      },
      {
        text: ' Спеціальний вид CSS, який застосовується лише до елементів із властивістю display: grid',
      },
    ]),
  },
  {
    question: ' Що таке специфічність селекторів в CSS?',
    answers: shuffleArray([
      {
        text: ' Показник пріоритету правила CSS, що розраховується за кількістю ID, класів/псевдокласів та типових селекторів у конкретному селекторі',
        correct: true,
      },
      {
        text: ' Властивість, яка визначає, наскільки швидко браузер застосовує стиль до елемента',
      },
      {
        text: ' Відсоткове значення, яке вказує, наскільки селектор відповідає елементу DOM',
      },
      {
        text: ' Число символів у селекторі, що використовується для автоматичної фіналізації властивостей',
      },
    ]),
  },
  {
    question: ' В чому різниця між псевдокласом та псевдоелементом в CSS?',
    answers: shuffleArray([
      {
        text: ' Псевдоклас (наприклад, :hover) застосовується до існуючого елемента при певній умові, а псевдоелемент (наприклад, ::before) створює віртуальний дочірній елемент всередині вибраного елемента',
        correct: true,
      },
      {
        text: ' Псевдоклас працює тільки з класами (class), а псевдоелемент тільки з id',
      },
      {
        text: ' Псевдоклас завжди успадковує стилі від батьківського елемента, а псевдоелемент ні',
      },
      {
        text: ' Псевдоклас можна використовувати лише з тегом <a>, а псевдоелемент — лише з тегом <div>',
      },
    ]),
  },
  {
    question: ' Що таке блочна модель CSS?',
    answers: shuffleArray([
      {
        text: ' Система, за якою кожен елемент розглядається як прямокутник із вмістом, відступами (padding), обрамленням (border) і зовнішнім відступом (margin)',
        correct: true,
      },
      {
        text: ' Концепція, за якою всі елементи стають блочними, якщо застосувати box-sizing: border-box',
      },
      {
        text: ' Спосіб групування елементів у flex-контейнер для побудови сітки',
      },
      {
        text: ' Модель, що визначає, як браузер обчислює opacity для блочних елементів',
      },
    ]),
  },
  {
    question: ' Яку роль виконує box-sizing?',
    answers: shuffleArray([
      {
        text: ' Визначає, чи входять поля (padding) і межі (border) у загальний розмір елемента (content-box або border-box)',
        correct: true,
      },
      {
        text: ' Автоматично обчислює глибину вкладеності блочних елементів у DOM',
      },
      {
        text: ' Змінює спосіб позиціонування елемента з абсолютного на відносне',
      },
      {
        text: ' Додає тінь до блочних елементів, щоб вони виглядали об’ємними',
      },
    ]),
  },
  {
    question: ' Які є види позиціонування елементів на сторінці?',
    answers: shuffleArray([
      { text: ' static, relative, absolute, fixed, sticky', correct: true },
      { text: ' inline, block, table, flex, grid' },
      { text: ' float, clear, align, justify' },
      { text: ' visible, hidden, collapsed, expanded' },
    ]),
  },
  {
    question: ' Що робить властивість z-index?',
    answers: shuffleArray([
      {
        text: ' Визначає шар (глибину) елемента в осі Z для контролю накладання елементів, діє лише для позиційованих елементів',
        correct: true,
      },
      {
        text: ' Контролює прозорість елемента залежно від його відстані від камери',
      },
      {
        text: ' Встановлює кількість пікселів, на які елемент відступає від країв вікна',
      },
      { text: ' Використовується для визначення рівня шрифту елемента' },
    ]),
  },
  {
    question: ' В чому різниця між px, em, rem?',
    answers: shuffleArray([
      {
        text: ' px — абсолютна одиниця пікселів; em — відносна до розміру шрифту батьківського елемента; rem — відносна до кореневого (<html>) розміру шрифту',
        correct: true,
      },
      {
        text: ' px — відносна до розміру шрифту браузера; em — абсолютна одиниця пікселів; rem — відносна до висоти вікна',
      },
      {
        text: ' px — відносна до висоти екрана; em — відносна до ширини екрана; rem — абсолютна одиниця пікселів',
      },
      {
        text: ' px — використовується тільки для зображень; em — тільки для тексту; rem — тільки для отступів',
      },
    ]),
  },
  {
    question:
      ' Що таке гумова, адаптивна та відзивчива верстка? В чому між ними різниця?',
    answers: shuffleArray([
      {
        text: ' Гумова верстка (fluid) використовує відносні одиниці (%, vw/vh) для масштабування під будь-який розмір екрану; адаптивна (adaptive) має кілька фіксованих точок перелому з різними макетами; відзивчива (responsive) поєднує обидва підходи, змінює макет залежно від розміру екрану, використовуючи медіазапити та відносні одиниці',
        correct: true,
      },
      {
        text: ' Гумова верстка використовує тільки flex-контейнери; адаптивна — тільки CSS grid; відзивчива — тільки абсолютне позиціонування',
      },
      {
        text: ' Гумова верстка означає фіксовану ширину сайту на будь-якому екрані; адаптивна — ширина понад 1200px; відзивчива — ширина до 320px',
      },
      {
        text: ' Гумова верстка змінює колір фону в залежності від ширини екрана; адаптивна — змінює шрифт; відзивчива — змінює картинки',
      },
    ]),
  },
  {
    question: ' В чому різниця між visibility:hidden и display:none?',
    answers: shuffleArray([
      {
        text: ' visibility:hidden ховає елемент, але він займає місце в потоці; display:none видаляє елемент із потоку, і він не займає жодного місця',
        correct: true,
      },
      {
        text: ' visibility:hidden робить елемент прозорим, але при кліку на область спрацює подія; display:none вимикає всі події на елементі, але залишає місце',
      },
      {
        text: ' visibility:hidden викликає перерендер документа, а display:none лише приховує елемент без перерендеру',
      },
      {
        text: ' visibility:hidden застосовується тільки до текстових елементів, а display:none — тільки до графічних',
      },
    ]),
  },
  {
    question: ' Чим відрізняються змінні var, let и const',
    answers: shuffleArray([
      {
        text: ' var має функціональну область видимості, let і const — блочну; const не дозволяє переназначати змінну після ініціалізації',
        correct: true,
      },
      {
        text: ' let дозволяє створювати глобальні змінні в будь-якому блоці, var — лише в функціях, а const працює лише в строгому режимі',
      },
      {
        text: ' var завжди піднімається в кінець блоку, let — у верхівку функції, а const — у верхівку всього скрипта',
      },
      {
        text: ' const автоматично переводить значення в незмінюваний тип даних, var — у null, а let — у undefined після першого присвоєння',
      },
    ]),
  },
  {
    question: ' Як дізнатись, чи є дані масивом? Наведи приклад.',
    answers: shuffleArray([
      {
        text: ' Використати Array.isArray(data), наприклад: Array.isArray([1,2,3]) поверне true',
        correct: true,
      },
      {
        text: ' Перевірити typeof data === "array", наприклад: typeof [1,2,3] === "array" поверне true',
      },
      {
        text: ' Перевірити data.constructor === Object, наприклад: [1,2,3].constructor === Object поверне true',
      },
      {
        text: ' Перевірити data instanceof Object, наприклад: [1,2,3] instanceof Object поверне true тільки для масивів',
      },
    ]),
  },
  {
    question: ' Які перебираючі методи масивів ви знаєте?',
    answers: shuffleArray([
      {
        text: ' map, filter, reduce, forEach, some, every, find, findIndex',
        correct: true,
      },
      { text: ' add, remove, update, clear, find, includes' },
      { text: ' append, prepend, slice, splice, merge, split' },
      { text: ' push, pop, shift, unshift, indexOf, lastIndexOf' },
    ]),
  },
  {
    question: ' Як обєднати масиви?',
    answers: shuffleArray([
      {
        text: ' Використати concat або оператор розпилення: arr1.concat(arr2) або [...arr1, ...arr2]',
        correct: true,
      },
      {
        text: " Використати метод join з порожнім роздільником: arr1.join('').concat(arr2.join(''))",
      },
      {
        text: ' Використати метод push на першому масиві для другого: arr2.push(arr1)',
      },
      {
        text: ' Використати оператор + напряму: arr1 + arr2 поверне новий масив, що містить обидва',
      },
    ]),
  },
  {
    question: ' Як дізнатись, чи знаходиться елемент в масиві?',
    answers: shuffleArray([
      {
        text: ' Використати includes або indexOf: arr.includes(value) поверне true, якщо є',
        correct: true,
      },
      {
        text: ' Використати метод find і порівняти з undefined: arr.find(el => el === value) !== undefined',
      },
      {
        text: ' Використати цикл for…in, щоб перевірити індекси, і якщо знайдено, повернути true',
      },
      {
        text: ' Використати JSON.stringify: JSON.stringify(arr).includes(JSON.stringify(value))',
      },
    ]),
  },
  {
    question:
      ' Чи можна використовувати цикл for in для масивів? Які недоліки такого методу?',
    answers: shuffleArray([
      {
        text: ' Так, але він перебирає ключі (індекси та прототипні властивості), що може призвести до непередбачених значень і порушити порядок, тому краще використовувати for, for…of або forEach',
        correct: true,
      },
      {
        text: ' Так, і це найшвидший спосіб перебору масиву в сучасних браузерах без жодних недоліків',
      },
      {
        text: ' Не можна взагалі, оскільки for in працює лише з об’єктами, а масиви інтерпретуються як рядки',
      },
      {
        text: ' Можна, але тільки якщо масив не містить більше 10 елементів — інакше цикл автоматично зупиниться',
      },
    ]),
  },
  {
    question: ' Що таке підняття (hoisting)?',
    answers: shuffleArray([
      {
        text: ' Механізм, за якого оголошення змінних (var) і функцій «піднімаються» вгору своєї області видимості до виконання коду',
        correct: true,
      },
      {
        text: ' Механізм, який автоматично переміщує всі імпорти на початок файлу, щоб модулі завантажувалися швидше',
      },
      {
        text: ' Спосіб оптимізації V8, що відкладає ініціалізацію змінних до першого звернення',
      },
      {
        text: ' Властивість strict mode, що забороняє використовувати необ’явлені змінні у функціях',
      },
    ]),
  },
  {
    question:
      ' Яким буде значення змінної var при зверненні до неї до її оголошення?',
    answers: shuffleArray([
      {
        text: ' undefined, оскільки оголошення піднімається, але ініціалізація відбувається на місці оголошення',
        correct: true,
      },
      {
        text: ' Error, оскільки var не дозволяє звертатись раніше оголошення у будь-якому випадку',
      },
      {
        text: ' null, оскільки змінна автоматично ініціалізується null перед виконанням',
      },
      {
        text: ' Значення NaN, оскільки під час підняття відбувається стандартне перетворення в число',
      },
    ]),
  },
  {
    question:
      ' Що буде, якщо звернутись до змінних let/const до їх оголошення?',
    answers: shuffleArray([
      {
        text: ' Буде помилка ReferenceError через temporal dead zone, бо оголошення let/const не піднімаються до доступного стану до оголошення',
        correct: true,
      },
      { text: ' Повернеться undefined, як і з var, але без помилки' },
      {
        text: ' Змінна буде неявно створена в глобальній області видимості з undefined',
      },
      { text: ' Змінна автоматично ініціалізується null без помилки' },
    ]),
  },
  {
    question: ' Що таке область видимості (Scope)? Яка вона буває?',
    answers: shuffleArray([
      {
        text: ' Область видимості — це контекст, у якому доступні змінні; буває глобальна, функціональна (для var) і блочна (для let/const)',
        correct: true,
      },
      {
        text: ' Область видимості — це частина DOM, де доступні скрипти; буває місцева та хмарна',
      },
      {
        text: ' Область видимості — це набір CSS-класів для видимості елементів; буває flex і grid',
      },
      {
        text: ' Область видимості — це рівень доступу у базі даних; буває public, private, protected',
      },
    ]),
  },
  {
    question: ' Для чого потрібен useEffect?',
    answers: shuffleArray([
      {
        text: ' Для виконання побічних ефектів після рендеру компонента, наприклад, запитів до API, підписок і очищення ресурсів',
        correct: true,
      },
      {
        text: ' Для встановлення початкового стану компонента перед його першим рендером',
      },
      {
        text: ' Щоб автоматично оновити контекст без перезавантаження сторінки',
      },
      {
        text: ' Для створення нових контекстів і передачі їх у дочірні компоненти',
      },
    ]),
  },
  {
    question: ' Чим відрізняється useEffect від useLayoutEffect?',
    answers: shuffleArray([
      {
        text: ' useLayoutEffect виконується синхронно після змін у DOM перед тим, як браузер намалює кадр, а useEffect виконується асинхронно після того, як зміни вже відображені',
        correct: true,
      },
      {
        text: ' useLayoutEffect запускається лише один раз при монтуванні, а useEffect — при кожному оновленні стану',
      },
      {
        text: ' useLayoutEffect призначений для обробки подій користувача, а useEffect — для роботи зі стилями елементів',
      },
      {
        text: ' useLayoutEffect виконується тільки в серверному рендерингу, а useEffect — тільки на клієнті',
      },
    ]),
  },
  {
    question: ' Що таке "лінива" ініціалізація стану в useState?',
    answers: shuffleArray([
      {
        text: ' Передача функції в useState, яка повертає початкове значення, щоб обчислення відбулося лише один раз при першому рендері',
        correct: true,
      },
      {
        text: ' Використання useState з null як початковим значенням, щоб стан створювався лише при першій взаємодії з компонентом',
      },
      {
        text: ' Використання useState у useEffect для відкладеного встановлення стану після монтажу компонента',
      },
      {
        text: ' Застосування memoization всередині useState, щоб стан автоматично кешувався при кожному рендері',
      },
    ]),
  },
  {
    question: ' Для чого потрібні useMemo та useCallback?',
    answers: shuffleArray([
      {
        text: ' Для мемоізації результатів обчислень (useMemo) і функцій (useCallback), щоб уникнути зайвих перерахунків і перегенерацій між рендерами',
        correct: true,
      },
      {
        text: ' Для автоматичної підстановки значень у залежностях useEffect без зайвих перевірок',
      },
      {
        text: ' Щоб створювати нові контексти та передавати їх у дочірні компоненти для всіх підписок',
      },
      {
        text: ' Щоб об’єднати кілька станів у один об’єкт для зручнішого оновлення через useState',
      },
    ]),
  },
  {
    question: ' Для чого потрібен redux? Який він має data flow?',
    answers: shuffleArray([
      {
        text: ' Для централізованого управління станом додатка з одностороннім (унідирекційним) потоком: компоненти → dispatch action → reducer → новий стан → render',
        correct: true,
      },
      {
        text: ' Щоб автоматично синхронізувати стан між усіма компонентами без використання dispatch або редюсерів',
      },
      {
        text: ' Для кешування HTTP-запитів та автоматичного оновлення стану компонента, коли дані змінюються на сервері',
      },
      {
        text: ' Щоб створювати локальні стани у кожному компоненті, не передаючи їх через пропси, з двостороннім потоком даних',
      },
    ]),
  },
  {
    question: ' Що таке redux middleware?',
    answers: shuffleArray([
      {
        text: ' Функції, які перехоплюють dispatch дій перед тим, як вони потраплять у редюсер, дозволяючи виконувати асинхронні дії або логування',
        correct: true,
      },
      {
        text: ' Компоненти React, які підключаються до стану Redux і надають його через пропси дочірнім компонентам',
      },
      {
        text: ' Спеціальні типи action, які автоматично відправляють декілька дій одночасно',
      },
      {
        text: ' Налаштування для підключення Redux до DevTools, щоб відображати історію змін стану',
      },
    ]),
  },
  {
    question: ' Для чого потрібні redux селектори?',
    answers: shuffleArray([
      {
        text: ' Для інкапсуляції логіки вибору та формування даних зі сховища, а також для мемоізації вибірок, щоби уникнути непотрібних перерахунків',
        correct: true,
      },
      {
        text: ' Щоб визначити порядок завантаження редюсерів у комбайнReducer',
      },
      {
        text: ' Для автоматичного оновлення стану сховища при зміні пропсів компонентів без використання dispatch',
      },
      {
        text: ' Для створення логіки асинхронних викликів у компоненті без thunk або saga',
      },
    ]),
  },
  {
    question: ' Чим відрізняється action від action creator?',
    answers: shuffleArray([
      {
        text: ' Action — це plain-об’єкт із типом (type) і даними (payload), а action creator — це функція, яка повертає цей об’єкт',
        correct: true,
      },
      {
        text: ' Action — це функція, яка викликається всередині компонента, а action creator — об’єкт, що містить тип та дані',
      },
      {
        text: ' Action автоматично виконується Redux-редюсером, а action creator лише зберігається в store до поки не стане потрібним',
      },
      {
        text: ' Action — це middleware, що відправляє запит на сервер, а action creator — це функція, що повертає middleware',
      },
    ]),
  },
  {
    question: ' Що таке редюсери у редакс?',
    answers: shuffleArray([
      {
        text: ' Чисті функції, які приймають поточний стан і action, а повертають новий стан без зміни попереднього',
        correct: true,
      },
      {
        text: ' Асинхронні функції, які виконують запити до API та оновлюють стан store після отримання відповіді',
      },
      {
        text: ' Класи, які інкапсулюють логіку відображення компонента та керують його життєвим циклом',
      },
      {
        text: ' Компоненти React, які викликають dispatch для оновлення стану при зміні пропсів',
      },
    ]),
  },
  {
    question: ' Що таке redux thunk?',
    answers: shuffleArray([
      {
        text: ' Middleware, що дозволяє action creators повертати функції замість об’єктів, для виконання асинхронних викликів і відправлення кількох дій',
        correct: true,
      },
      {
        text: ' Спеціальний тип селектора, який виконується лише після завершення всіх асинхронних операцій у store',
      },
      {
        text: ' Функція, яка автоматично додає таймаут до кожного dispatch у Redux для запобігання зависання коду',
      },
      {
        text: ' Метод у reduce, який дозволяє об’єднувати кілька редюсерів у один великий редюсер для складних проектів',
      },
    ]),
  },
  {
    question: ' Що таке createSlice?',
    answers: shuffleArray([
      {
        text: ' Утиліта з Redux Toolkit для створення «слайсу» стану: вона автоматично генерує редюсери та відповідні action creators',
        correct: true,
      },
      {
        text: ' Функція, що динамічно завантажує частину стану із сервера під час рендеру компонента',
      },
      {
        text: ' Компонент React, який обгортає інші компоненти й надає до них доступ до Redux-сховища',
      },
      {
        text: ' HOC (Higher-Order Component), який об’єднує кілька редюсерів у один головний редюсер',
      },
    ]),
  },
  {
    question: ' Що таке createAsyncThunk?',
    answers: shuffleArray([
      {
        text: ' Утиліта з Redux Toolkit для створення асинхронних action creators, що автоматично генерують pending/fulfilled/rejected дії',
        correct: true,
      },
      {
        text: ' Метод у Redux, який дозволяє викликати декілька middleware одночасно перед відправкою action',
      },
      {
        text: ' Спеціальний селектор, який виконує асинхронні запити і повертає результат без dispatch',
      },
      {
        text: ' HOC, що обгортає компонент і автоматично виконує API-запити під час монтування',
      },
    ]),
  },
  {
    question: ' Що таке repaint и reflow?',
    answers: shuffleArray([
      {
        text: ' Reflow (layout) обчислює нову розкладку елементів при зміні розмірів або структури, а repaint лише перерисовує пікселі без зміни макету',
        correct: true,
      },
      {
        text: ' Repaint обчислює розкладку елементів у DOM, а Reflow змінює тільки кольори та тіні',
      },
      {
        text: ' Reflow лише перерисовує видимі частини сторінки, а Repaint обчислює новий макет і місця для елементів',
      },
      {
        text: ' Repaint виконується лише при скролі сторінки, а Reflow — при зміні глобальних CSS-змінних',
      },
    ]),
  },
  {
    question: ' Яка різниця між відносною та абсолютною адресою?',
    answers: shuffleArray([
      {
        text: ' Відносна адреса вказує шлях від поточного документа або каталогу, а абсолютна містить повний URL із протоколом та доменом',
        correct: true,
      },
      {
        text: ' Відносна адреса завжди починається з "/", а абсолютна — з "./" або "../"',
      },
      {
        text: ' Абсолютна адреса вказує на внутрішній ресурс сайту, а відносна — на зовнішній',
      },
      {
        text: ' Відносна адреса використовується тільки в CSS, а абсолютна — тільки в HTML',
      },
    ]),
  },
  {
    question: ' Різниця між тегом та елементом?',
    answers: shuffleArray([
      {
        text: ' Тег — це текстова розмітка у HTML (наприклад, <div>), а елемент — це об’єкт у DOM, який створюється цим тегом із властивостями, атрибутами та вмістом',
        correct: true,
      },
      {
        text: ' Тег — це властивість CSS, що задає стиль, а елемент — це будь-яка HTML-компонента, яка має стилі',
      },
      {
        text: ' Тег — це JavaScript-об’єкт, що відповідає HTML-розмітці, а елемент — це виклик цього об’єкта',
      },
      {
        text: ' Тег — це файл із розширенням .html, а елемент — це будь-який тег всередині цього файлу',
      },
    ]),
  },
  {
    question: ' Коли ви використовуєте <button> , а коли <a>?',
    answers: shuffleArray([
      {
        text: ' <button> використовується для дій (наприклад, відправка форми або виклик JS-функції), а <a> — для навігації за URL або скачування ресурсів',
        correct: true,
      },
      {
        text: ' <button> підходить лише для серверних запитів, а <a> — тільки для внутрішніх якірних посилань',
      },
      {
        text: '<a> автоматично відправляє форму при натисканні, а <button> лише змінює колір при наведенні',
      },
      {
        text: ' <button> використовується лише у формі, а <a> — виключно поза формою',
      },
    ]),
  },
  {
    question: ' Для чого потрібен атрибут type у кнопки?',
    answers: shuffleArray([
      {
        text: ' Щоб вказати поведінку кнопки: "submit" для відправки форми, "reset" для скидання полів, "button" для виконання кастомних дій без відправки',
        correct: true,
      },
      {
        text: ' Щоб автоматично підключити потрібний CSS-фреймворк залежно від типу кнопки',
      },
      {
        text: ' Щоб змінювати розмір кнопки залежно від розміру екрана: "small", "medium", "large"',
      },
      {
        text: ' Щоб визначати, чи кнопка повинна бути видимою або прихованою за замовчуванням',
      },
    ]),
  },
  {
    question: ' Різниця між checkbox та radio?',
    answers: shuffleArray([
      {
        text: ' <input type="checkbox"> дозволяє вибрати кілька опцій одночасно, а <input type="radio"> належить до групи з однаковим name та дозволяє вибрати лише одну опцію',
        correct: true,
      },
      {
        text: ' Radio-кнопки можна стилізувати за допомогою псевдокласів :checked, а checkbox — лише через JavaScript',
      },
      {
        text: ' Checkbox завжди зберігає вибране значення на сервері, а radio — тільки локально в браузері',
      },
      {
        text: ' Radio використовують для відправки файлів, а checkbox — для введення тексту',
      },
    ]),
  },
  {
    question:
      ' Що таке наслідування стилів в CSS? І що таке каскадність в CSS?',
    answers: shuffleArray([
      {
        text: ' Наслідування — це передача деяких властивостей (наприклад, color, font-family) від батьківського елемента до нащадків, а каскадність — механізм вибору одного правила серед кількох за пріоритетом (специфічність, порядок оголошення, важливість)',
        correct: true,
      },
      {
        text: ' Наслідування — це автоматичне додавання всіх властивостей батька до нащадка, а каскадність — це механізм поділу стилів між різними CSS-файлами за умовами @media',
      },
      {
        text: ' Наслідування — це процес, коли елементи успадковують HTML-розмітку, а каскадність — коли кілька CSS-файлів завантажуються одночасно',
      },
      {
        text: ' Наслідування і каскадність — це синоніми, які означають пріоритет декларованих стилів перед браузерними стандартними',
      },
    ]),
  },
  {
    question: ' В чому різниця між контентними і фоновими зображеннями?',
    answers: shuffleArray([
      {
        text: ' Контентні зображення (<img>) є частиною розмітки та семантики сторінки, впливають на доступність і SEO, а фонова картинка (background-image) виступає декоративним елементом через CSS і не несе семантичного значення',
        correct: true,
      },
      { text: ' Контентні зображення кешуються браузером, а фонові — ні' },
      {
        text: ' Фонова картинка завжди відображається зверху всіх елементів, а контентна — під ними',
      },
      {
        text: ' Контентні зображення не можна масштабувати за допомогою CSS, а фонова картинка — можна',
      },
    ]),
  },
  {
    question:
      ' Чому у <img> та <input> не має псевдоелементів ::before, ::after?',
    answers: shuffleArray([
      {
        text: ' Тому що вони є «replaced elements» (заміщеними елементами), і їхній вміст визначається браузером/операційною системою, а не внутрішньою розміткою, тому псевдоелементи не можуть вставлятися',
        correct: true,
      },
      {
        text: ' Тому що псевдоелементи можна застосовувати тільки до блочних елементів, а <img> і <input> завжди inline',
      },
      {
        text: ' Через обмеження HTML5, яке забороняє використовувати ::before/::after із будь-якими тегами, що мають атрибут src',
      },
      {
        text: ' Тому що вони автоматично створюють власні псевдоелементи, які замінюють стандартні ::before/::after',
      },
    ]),
  },
  {
    question: ' Для чого потрібна функція calc в CSS?',
    answers: shuffleArray([
      {
        text: ' Для динамічного обчислення значень (наприклад, ширини, відступів) з різними одиницями, наприклад calc(100% - 20px)',
        correct: true,
      },
      {
        text: ' Щоб автоматично конвертувати пікселі в em та rem без написання додаткового коду',
      },
      {
        text: ' Для створення циклічних анімацій, які розраховують кількість кадрів на основі тривалості',
      },
      {
        text: ' Щоб об’єднати кілька файлів CSS в один під час рендерингу браузером',
      },
    ]),
  },
  {
    question: ' Різниця між Function Declaration та Function Expression?',
    answers: shuffleArray([
      {
        text: ' Function Declaration піднімається (hoisting) і доступна до оголошення, тоді як Function Expression присвоюється змінній і піднімає лише ім’я змінної (значення буде undefined до виконання присвоєння)',
        correct: true,
      },
      {
        text: ' Function Expression автоматично виконується при завантаженні скрипта, а Function Declaration потрібно викликати вручну',
      },
      {
        text: ' Function Declaration завжди є анонімною, а Function Expression завжди має ім’я',
      },
      {
        text: ' Function Expression створює окремий потік виконання, а Function Declaration виконується в головному потоці',
      },
    ]),
  },
  {
    question: ' Що таке callback функції?',
    answers: shuffleArray([
      {
        text: ' Функція, яка передається як аргумент до іншої функції і викликається пізніше або після завершення певної операції',
        correct: true,
      },
      {
        text: ' Спеціальний тип функції, який завжди повертає проміс і виконується асинхронно',
      },
      {
        text: ' Функція, що виконується автоматично після завантаження сторінки без прямого виклику в коді',
      },
      {
        text: ' Функція, що виключно використовується для обробки помилок у try/catch-блоках',
      },
    ]),
  },
  {
    question: ' Чим стрілкова функція відрізняється від звичайних функцій?',
    answers: shuffleArray([
      {
        text: ' Стрілкові функції не мають власного this (беруть його з оточення), не мають власного об’єкта arguments і не можуть бути використані як конструктор (без new)',
        correct: true,
      },
      {
        text: ' Стрілкові функції виконуються завжди асинхронно, навіть якщо всередині немає промісів',
      },
      {
        text: ' Стрілкові функції автоматично повертають об’єкт, навіть якщо немає return',
      },
      {
        text: ' Стрілкові функції не можна викликати всередині інших функцій через обмеження синтаксису',
      },
    ]),
  },
  {
    question: ' Чи є аналог arguments для стрілкових функцій?',
    answers: shuffleArray([
      {
        text: ' Ні, у стрілкових функцій немає власного arguments; замість цього слід використовувати REST-параметри (...args)',
        correct: true,
      },
      {
        text: ' Так, у стрілкових функцій є спеціальний об’єкт __args__, який працює як arguments',
      },
      {
        text: ' arguments автоматично прив’язується до this у стрілкових функціях, тому його не видно явно',
      },
      {
        text: ' У стрілкових функцій arguments передається через глобальний об’єкт window.arguments',
      },
    ]),
  },
  {
    question: ' Як викликати функцію із затримкою в 10 секунд?',
    answers: shuffleArray([
      { text: ' Використати setTimeout(функція, 10000)', correct: true },
      { text: ' Використати setInterval(функція, 10000)' },
      {
        text: ' Викликати функцію через Promise.resolve().then(() => setTimeout(функція, 10000))',
      },
      { text: ' Використати sleep(10000).then(() => функція())' },
    ]),
  },
  {
    question: ' Що таке замикання (Closures)? Для чого воно використовується?',
    answers: shuffleArray([
      {
        text: ' Замикання — це комбінація функції та лексичного контексту, у якому вона була створена, що дозволяє зберігати доступ до зовнішніх змінних навіть після виконання зовнішньої функції',
        correct: true,
      },
      {
        text: ' Замикання — це процес закриття браузерної вкладки після виконання асинхронного коду',
      },
      {
        text: ' Замикання — це функція, яка автоматично викликається при натисканні кнопки “close” у вікні браузера',
      },
      {
        text: ' Замикання — це спеціальний метод в об’єкті Function.prototype, що закриває область видимості після виконання функції',
      },
    ]),
  },
  {
    question: ' Основні принципи ООП?',
    answers: shuffleArray([
      {
        text: ' Абстракція, Інкапсуляція, Наслідування і Поліморфізм',
        correct: true,
      },
      { text: ' Hoisting, Scoping, Context, Prototyping' },
      { text: ' DRY, KISS, YAGNI, SOLID' },
      { text: ' Map, Filter, Reduce, ForEach' },
    ]),
  },
  {
    question: ' Що таке this?',
    answers: shuffleArray([
      {
        text: ' Спеціальний псевдонім, що посилається на об’єкт, у контексті якого виконується функція; залежить від способу виклику (контексту виконання)',
        correct: true,
      },
      {
        text: ' Завжди глобальний об’єкт (window у браузері або global у Node.js), незалежно від способу виклику функції',
      },
      { text: ' Посилання на саму функцію як об’єкт у пам’яті' },
      {
        text: ' Метод у кожному об’єкті, що повертає унікальний ідентифікатор об’єкта',
      },
    ]),
  },
  {
    question: ' Як можна змінити контекст виклику функції?',
    answers: shuffleArray([
      {
        text: ' Використати методи call, apply або bind, передаючи потрібний об’єкт як this',
        correct: true,
      },
      {
        text: ' Додати атрибут data-context="новийКонтекст" до елемента HTML, і браузер автоматично змінить this',
      },
      {
        text: ' Використати оператор індексації функції: func[новийКонтекст]()',
      },
      {
        text: ' Змінити значення глобальної змінної window.this на потрібний об’єкт перед викликом',
      },
    ]),
  },
  {
    question: ' Чи можна змінити контекст стрілкової функції?',
    answers: shuffleArray([
      {
        text: ' Ні, у стрілкових функцій this прив’язаний лексично до зовнішнього контексту і його не змінити навіть через call, apply або bind',
        correct: true,
      },
      {
        text: ' Так, достатньо викликати стрілкову функцію через метод bind із новим контекстом',
      },
      {
        text: ' Так, якщо застосувати метод call, у стрілковій функції this зміниться на переданий об’єкт',
      },
      {
        text: ' Так, контекст змінюється автоматично, якщо функцію викликати всередині іншої функції',
      },
    ]),
  },
  {
    question: ' Що таке flex-контейнер та flex-елемент?',
    answers: shuffleArray([
      {
        text: ' Flex-контейнер — це елемент із display: flex, який встановлює контекст для розташування його дочірніх елементів (flex-елементів); flex-елемент — це безпосередній нащадок flex-контейнера, який керується правилами flexbox',
        correct: true,
      },
      {
        text: ' Flex-контейнер — це елемент із position: flex, який фіксує позицію дочірніх елементів, а flex-елемент — елемент із display: block у контейнері',
      },
      {
        text: ' Flex-контейнер — це псевдоклас, який визначає напрямок розмітки, а flex-елемент — це будь-який елемент із атрибутом data-flex',
      },
      {
        text: ' Flex-контейнер автоматично додає тіні та відступи дітям, а flex-елемент — це елемент, який підтримує grid-сітку всередині себе',
      },
    ]),
  },
  {
    question: ' Що таке flex-вісь?',
    answers: shuffleArray([
      {
        text: ' Flex-вісь — це уявна лінія всередині flex-контейнера, уздовж якої розташовуються flex-елементи; головна вісь (main axis) задається властивістю flex-direction, а поперечна (cross axis) — перпендикулярна їй',
        correct: true,
      },
      {
        text: ' Flex-вісь — це вертикальна лінія, що розділяє контейнер на дві частини та автоматично вирівнює елементи за центром',
      },
      {
        text: ' Flex-вісь — це рядок HTML-коду, який визначає, скільки елементів можна розташувати в одному рядку container',
      },
      {
        text: ' Flex-вісь — це властивість CSS, яка задає товщину кордону між двома flex-елементами',
      },
    ]),
  },
  {
    question: ' Які відмінності у mobile first та desktop first підходів?',
    answers: shuffleArray([
      {
        text: ' Mobile first починається з базових стилів для мобільних пристроїв із вузьким екраном і далі додає стилі для більших ширин через media queries; desktop first пише стилі для великих екранів спочатку й додає media queries для зменшення до мобільних',
        correct: true,
      },
      {
        text: ' Mobile first використовує тільки відносні одиниці (%, em), а desktop first — тільки абсолютні (px)',
      },
      {
        text: ' Mobile first дозволяє використовувати JavaScript для зміни макета, а desktop first — лише CSS',
      },
      {
        text: ' Desktop first підтримує тільки flexbox, а mobile first — тільки grid-сітку',
      },
    ]),
  },
  {
    question: ' Які переваги у svg перед png або jpeg?',
    answers: shuffleArray([
      {
        text: ' SVG — векторний формат, тому його можна масштабувати без втрати якості, він займає менше місця для простих іконок, підтримує анімацію й редагується безпосередньо в коді',
        correct: true,
      },
      {
        text: ' SVG використовує менше пам’яті GPU, ніж будь-яке растрове зображення, тому пришвидшує завантаження будь-якої картинки',
      },
      {
        text: ' SVG автоматично конвертується у WebP під час завантаження, щоб зменшити розмір файлу',
      },
      {
        text: ' SVG підтримує прозорість тільки в браузерах Chrome, а PNG/JPEG — у всіх браузерах',
      },
    ]),
  },
  {
    question: ' Яка різниця між rgb, rgba та hex?',
    answers: shuffleArray([
      {
        text: ' rgb(r, g, b) задає колір через три компоненти без альфа-каналу; rgba(r, g, b, a) додає альфа-канал для прозорості; hex (#RRGGBB або #RGB) задає колір шістнадцятковою нотацією без окремого альфа-каналу (для прозорості існують формати #RRGGBBAA)',
        correct: true,
      },
      {
        text: ' rgb автоматично конвертується у cmyk при друку, rgba — ні, а hex — це лише сірі відтінки',
      },
      {
        text: ' rgb задає колір у відсотках, rgba — у пікселях, а hex — у сантиметрах екрану',
      },
      {
        text: ' hex завжди має фіксований формат довжини 8 символів, rgb — динамічний та змінюється залежно від яскравості, rgba — використовується тільки для фонів',
      },
    ]),
  },
  {
    question: ' Чим відрізняється лінійний та радіальний градієнти?',
    answers: shuffleArray([
      {
        text: ' Лінійний градієнт (linear-gradient) створює зміну кольору вздовж прямої лінії (зазначається напрямок або кут), а радіальний (radial-gradient) поширюється від центру до периферії по колу або еліпсу',
        correct: true,
      },
      {
        text: ' Лінійний градієнт завжди вертикальний, а радіальний — горизонтальний, незалежно від вказаних параметрів',
      },
      {
        text: ' Радіальний градієнт підтримує тільки два кольори, а лінійний — необмежену кількість',
      },
      {
        text: ' Лінійний градієнт використовується лише для фону body, а радіальний — тільки для кордонів елементів',
      },
    ]),
  },
  {
    question: ' Що таке прототип об’єкту?',
    answers: shuffleArray([
      {
        text: ' Об’єкт, до якого посилається [[Prototype]] іншого об’єкта і який містить спільні властивості та методи',
        correct: true,
      },
      {
        text: ' Спеціальний тип змінної, що зберігає функції для роботи з об’єктами',
      },
      {
        text: ' Метод у кожного об’єкта, який викликається під час його створення',
      },
      {
        text: ' Функція, що повертає копію об’єкта разом із його властивостями',
      },
    ]),
  },
  {
    question: ' Як працює прототипне наслідування в JS?',
    answers: shuffleArray([
      {
        text: ' Якщо потрібно взяти властивість або метод, JS спочатку шукає її в самому об’єкті, а якщо не знаходить — подивиться у прототипі та далі по ланцюжку прототипів',
        correct: true,
      },
      {
        text: ' Під час створення нового об’єкта всі властивості з базового об’єкта копіюються до нового, а прототип не використовується',
      },
      {
        text: ' JS створює окрему копію всіх методів прототипу в кожному екземплярі, тому посилань на прототип не існує',
      },
      {
        text: ' Прототипне наслідування працює лише для класів ES6, а не для функцій-конструкторів',
      },
    ]),
  },
  {
    question: ' Як створити об’єкт, в якому не буде прототипу?',
    answers: shuffleArray([
      {
        text: ' Використати Object.create(null), щоб створити об’єкт без [[Prototype]]',
        correct: true,
      },
      { text: ' Викликати new Object(false), щоб обрати пустий прототип' },
      {
        text: ' Створити об’єкт літералом {} та потім видалити __proto__ вручну',
      },
      {
        text: " Виконати JSON.parse('{}'), оскільки такий об’єкт не матиме прототипу",
      },
    ]),
  },
  {
    question:
      ' Як перевірити, чи є властивість об’єкта його особистою властивістю або це властивість прототипу?',
    answers: shuffleArray([
      {
        text: ' Використати obj.hasOwnProperty(prop) або Object.prototype.hasOwnProperty.call(obj, prop)',
        correct: true,
      },
      {
        text: ' Перевірити, чи typeof obj[prop] === "undefined" — якщо true, то це властивість прототипу',
      },
      {
        text: ' Якщо prop in obj поверне true, то це особиста властивість, інакше — прототипна',
      },
      {
        text: ' Використати obj.prototype.hasOwnProperty(prop), щоб з’ясувати, чия це властивість',
      },
    ]),
  },
  {
    question: ' Чим відрізняється функція-конструктор і клас?',
    answers: shuffleArray([
      {
        text: ' Функція-конструктор — це звичайна функція, яку викликають з new; class у ES6 — синтаксичний цукор над функцією-конструктором, він завжди працює у строгому режимі та не дозволяє виклик без new',
        correct: true,
      },
      {
        text: ' Функція-конструктор створює лише примітивні властивості, а клас — лише методи',
      },
      {
        text: ' Клас є результатом виконання функції-конструктора під час рантайму, а функція-конструктор — лише декларація, яка не виконується',
      },
      {
        text: ' Функція-конструктор не має доступу до prototype, а класи завжди зберігають усі методи в самій функції, а не в prototype',
      },
    ]),
  },
  {
    question:
      ' Що потрібно зробити, щоб метод класу потрапив до його екземпляру?',
    answers: shuffleArray([
      {
        text: ' Оголосити метод всередині тіла class поза конструктором — тоді він автоматично потрапить у prototype і буде доступний усім екземплярам',
        correct: true,
      },
      { text: ' Додати метод у конструктор як this.method = function() { … }' },
      {
        text: ' Викликати метод у тілі класу після export, щоб він зареєструвався в екземплярі',
      },
      {
        text: ' Зберегти метод у змінній перед створенням класу та потім приєднати її до об’єкта через Object.define()',
      },
    ]),
  },
  {
    question: ' Яка різниця між cookie, sessionStorage та localStorage?',
    answers: shuffleArray([
      {
        text: ' cookie передаються з кожним HTTP-запитом і мають термін придатності; sessionStorage зберігає дані лише в межах однієї вкладки до її закриття; localStorage зберігає дані постійно в браузері, поки не очистити вручну',
        correct: true,
      },
      {
        text: ' cookie не можна читати з JavaScript, тільки передавати серверу; sessionStorage автоматично синхронізується між вкладками браузера; localStorage видаляється після перезавантаження сторінки',
      },
      {
        text: ' sessionStorage зберігає дані у пам’яті сервера, а localStorage — у базі даних браузера',
      },
      {
        text: ' cookie — це файловий кеш на диску; sessionStorage — тимчасовий файл у каталозі браузера; localStorage — постійний файл налаштувань для сайту',
      },
    ]),
  },
  {
    question: ' Що таке Promise?',
    answers: shuffleArray([
      {
        text: ' Об’єкт, що репрезентує відкладену асинхронну операцію зі станами pending, fulfilled та rejected',
        correct: true,
      },
      {
        text: ' Функція, яка автоматично виконується після завантаження DOM і повертає результат синхронної операції',
      },
      {
        text: ' Спеціальний масив, що містить усі функції-колбеки, які будуть виконані під час події',
      },
      {
        text: ' Об’єкт для роботи з localStorage, який повертає дані після асинхронного збереження',
      },
    ]),
  },
  {
    question: ' Для чого потрібен метод Promise.all та Promise.race?',
    answers: shuffleArray([
      {
        text: ' Promise.all чекає завершення всіх промісів і повертає масив результатів або відразу reject, якщо один із них помилковий; Promise.race повертає результат першого завершеного промісу (якщо він fulfilled, буде resolved, якщо rejected — rejected)',
        correct: true,
      },
      {
        text: ' Promise.all послідовно виконує проміси, а Promise.race ділить їх на частини для паралельного виконання',
      },
      {
        text: ' Promise.all завжди повертає результат у вигляді об’єкта { success: [], error: [] }, а Promise.race тільки список помилок',
      },
      {
        text: ' Promise.race чекає завершення всіх промісів за найменшим timeout, а Promise.all повертає результат лише останнього промісу',
      },
    ]),
  },
  {
    question: ' Що таке async/await і для чого він потрібен?',
    answers: shuffleArray([
      {
        text: ' Синтаксичний цукор для роботи з промісами: async позначає функцію, яка повертає проміс, а await дозволяє «зупинити» виконання всередині async, поки проміс не завершиться, що робить код читабельнішим',
        correct: true,
      },
      {
        text: ' Спеціальні методи для роботи з event loop, які створюють новий потік виконання для кожного асинхронного виклику',
      },
      {
        text: ' API браузера для використання Web Workers без створення окремих файлів',
      },
      {
        text: ' Бібліотека, що перетворює всі колбеки в синхронні функції автоматично',
      },
    ]),
  },
  {
    question: ' Як обробити помилки в async/await?',
    answers: shuffleArray([
      {
        text: ' Використати конструкцію try { await … } catch(e) { … } всередині async-функції або додати .catch() до виклику async-функції, оскільки вона повертає проміс',
        correct: true,
      },
      {
        text: ' Поставити параметр onerror="…" в тегі script, щоб він ловив помилки async-коду',
      },
      {
        text: ' Викликати процес через setTimeout з помилковим callback, щоб обробити помилку асинхронно',
      },
      {
        text: ' Додати оператор awaitError перед викликом, щоб автоматично перехопити помилки',
      },
    ]),
  },
  {
    question: ' Що таке event loop?',
    answers: shuffleArray([
      {
        text: ' Механізм, який відстежує стек викликів і чергу подій/мікротасків, забезпечуючи асинхронність у JS: коли стек порожній, event loop бере наступну задачу з черги',
        correct: true,
      },
      {
        text: ' Спеціальна функція в браузері, яка виконує рендеринг CSS-анімацій під час прокрутки',
      },
      {
        text: ' Модуль Node.js, який відповідає за управління потоками в файловій системі',
      },
      {
        text: ' Бібліотека для створення нескінченних циклів анімації в Canvas',
      },
    ]),
  },
  {
    question: ' Що таке CRUD?',
    answers: shuffleArray([
      {
        text: ' Абревіатура від Create, Read, Update, Delete — базові операції для роботи з даними в будь-якому додатку чи базі даних',
        correct: true,
      },
      {
        text: ' Технологія, яка автоматично генерує форми для введення даних у базу',
      },
      {
        text: ' Конфігурація Router’а в React, що відповідає за маршрути Create, Read, Update, Delete',
      },
      {
        text: ' Методологія тестування API під час створення, читання, оновлення та видалення файлів у файловій системі',
      },
    ]),
  },
  {
    question: ' Які методи HTTP-запитів ви знаєте?',
    answers: shuffleArray([
      { text: ' GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD', correct: true },
      { text: ' SEND, FETCH, STREAM, UPLOAD, DOWNLOAD' },
      { text: ' CONNECT, TRANSFER, MODIFY, REMOVE, QUERY' },
      { text: ' TRACE, PUSH, PULL, SUBSCRIBE, UNSUBSCRIBE' },
    ]),
  },
];

export default questions;
